Из данного доклада я узнал:
 1) зачем может понадобиться при разработке десктопного приложения создавать новый процесс. Если приложение 32 битное, 
 то ему можно адресовать не более 4 гб оперативной памяти, для увеличения количества памяти нужно создать новый 64 битный процесс.
 Также можно создать новый процесс для внешнего ненадежного API, который переодически "ломает" прилоложение. Таким образом будет "ломаться" 
 созданный нами процесс, а не главное приложение.
 2) В высокопроизводительном коде не рекомендуется использовать примитив синхронизации EventWaitHandle так как он работает на порядок медленнее,
 чем примитив lock и Monitor.
 3) Примитив Mutex позволяет синхронизировать межпроцессное взаимодействие, например когда в нескольких Visual Studio открывают одит и тот же Solution.
 4) В примитиве синхронизации ReadWriteLockSlim используется политика синхронизации, при которой новые потоки для чтения блокируются, если есть поток для записи,
 который ожидает вход в блокировку. Таким образом не возникает ситуации когда потоки для чтения сменяют друг - друга и поток для записи находится в вечном ожидании.
 5) Класс SynchronizationContex основная точка многопоточности, через него проходит весь posting сообщений, все lock и event проходят через метод wait класса SynchronizationContex.
 6) Скорость работы асинхронного програмирования может упасть при работе с HDD.
Было не понятно про COM объекты, потому что первый раз с ними сталкиваюсь
 
 