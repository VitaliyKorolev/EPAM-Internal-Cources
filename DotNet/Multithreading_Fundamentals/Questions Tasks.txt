1) Что такое Task?
 Task - представляет собой одну операцию, которая не возвращает значение и обычно выполняется асинхронно. Task объекты являются 
одним из центральных компонентов асинхронного шаблона на основе задач, впервые появившиеся в платформа .NET Framework 4.

2) Чем Task отличается от Thread?
 Task представляет собой более высокий уровень абстракции чем Thread, задача не 
создает свой собственный поток ОС. Вместо этого задачи выполняются благодаря планировщику (класс TaskScheduler); планировщик по умолчанию 
просто запускается в пуле потоков.

3) Какие есть способы создать и запустить Task?
 Задачу можно создать и запустить 4 способами:

 а) Задача создается путем вызова конструктора класса Task, но запускается путем вызова метода Start();
 б) Задача создается и запускается в одном вызове метода путем вызова TaskFactory.StartNew(Action<Object>, Object) метода;
 в) Задача создается и запускается в одном вызове метода путем вызова Run(Action) метода;
 г) Задача выполняется синхронно в основном потоке путем вызова RunSynchronously() метода.

4) На каком потоке будет выполняться запущенный Task?
 По умолчанию задача  просто запускается на одном из потоков ThreadPool.

5) Как можно запустить Task на "отдельном потоке"? Когда это необходимо делать?
 Запустить задачу на отдельном потоко можно с помощью выражения:
 Task task = Task.Factory.StartNew (() => ..., TaskCreationOptions.LongRunning);
 Это необходимо делать для длительных блокируюших операций. Этот подход можно использовать когда таких операций не много.
 Если операций много то это может ухудшить производительность приложения. В таких случая лучше использовать асинхронные функции при I/O bound вычислениях,
 или producer/consumer queue при CPU bound вычислениях
 
6) Как можно выполнить действия в "продолжении" выполненного Task?
 Можно вызвать у задачи метод ContinueWith, Можно вызвать задачи метод GetAwaiter а далее у объекта awaiter присвоить OnCopleted делегат,
 который будет выполняться после завершения задачи:
	var awaiter = primeNumberTask.GetAwaiter();
	awaiter.OnCompleted (() =>
	{
 	 int result = awaiter.GetResult();
 	 Console.WriteLine (result); // Writes result
	});



&) Зачем нужны Concurrent Collection? Какие есть Concurrent Collection?
 Классы коллекций в пространства имен System.Collections.Concurrent поддерживают потокобезопасные операции добавления и удаления, 
которые избегают блокировок везде, где это возможно, и применяют только детально настроенные блокировки. Класс параллельных 
коллекций не требует использовать блокировки в пользовательском коде для доступа к элементам. Классы параллельных коллекций могут 
значительно повысить производительность по сравнению с типами System.Collections.ArrayList и System.Collections.Generic.List<T> 
(где блокировка реализуется пользователем) в сценариях одновременного добавления и удаления элементов коллекции из нескольких потоков.
Существует BlockingCollection<T>, ConcurrentBag<T>, ConcurrentDictionary<TKey,TValue>, ConcurrentQueue<T>, ConcurrentStack<T>.