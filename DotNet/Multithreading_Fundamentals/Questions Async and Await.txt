1)На сколько логических частей делится async/await метод? Когда они выполняются и в какой последовательности?

 a) Вызывающий метод вызывает и ожидает асинхронный метод
 б)В Асинхронном методе происходит событие, которое приостанавливает ход выполнения. Например, методу необходимо 
 подождать завершения загрузки или произошло другое блокирующее действие. Чтобы избежать блокировки ресурсов,
 асинхронный метод передает управление вызывающему объекту.
 в) Вызывающий метод продолжает выполнение работы которая не зависит от результата асинхронного метода,когда вся 
 такая работа выполнениа вызывается await и управление передается вверх по стеку вызывов.
 г) Асинхронный метод возвращает значение задачи, когда его работа приостанавливается (шаги 3 и 6). 
 Когда асинхронный метод в конечном счете завершает работу, задача помечается как завершенная и результат, 
 при его наличии, сохраняется в задаче.

2) Как правильно отменять асинхронные операции?
 С помощи CancellationToken, токен передается в задачу 
 task = Task.Run( () => Thread.Sleep(2000),token);
 вызывается метод Cancel у CancellationToken.

3) Опишите как будет работать данный код (параллельно или последовательно?) Почему?

 public async void Do()
 {
    await FooAsync1();
    await FooAsync2();
 
    Foo();
 }
 Данный код будет работать последовательно, сначала будет вызвана FooAsync1() и Do() будет ожидать окончания метода,
 потом будет FooAsync2() и Do() также будет ожидать окончание. Потом вызовется Foo()

4) Создайте Winform приложение с одной кнопкой и запустите следующий код:
private async void button1_Click(object sender, EventArgs e)
{
    int result = DoSomeAsync().Result; //1
}
 
private async Task<int> DoSomeAsync()
{
    await Task.Delay(100).ConfigureAwait(true); //2
    return 42;
}
 
Клик по кнопке здесь приводит к дедлоку. UI поток стартует новый I/O поток на строке «2» и уходит в спящий режим на строке «1», 
ожидая завершения работы. После того как I/O поток заканчивает выполнение, оставшаяся часть метода DoSomeWorkAsync передается на 
выполнение вызывающему (UI) потоку. Но тот в это время находится в спящем режиме, ожидая завершения метода.

Как нужно использовать configureAwait, если пишите стороннюю библиотеку, и почему?
 Если вы пишете код библиотеки общего назначения, используйте ConfigureAwait(false).
 Если код после await на самом деле не требует запуска в исходном контексте, используя ConfigureAwait(false) 
 можно избежать всех этих затрат: ему не нужно будет стоять в очереди без необходимости, он может использовать все доступные оптимизации 

5) Во что компилятор преобразуют async method?
При использовании async/await, компилятор создаёт машину состояний, которая хранит переменные и стек.
 