
1)Как определить, что стандартный класс/метод/свойство потокобезопасно или нет?
 По умолчанию, объекты любого типа, его свойства, методы (а также статических свойств/методов и тп) рассчитаны на работу в «одном потоке».
 Чтобы точно знать какие члены класса (и объекты класса) поддерживают стабильную работу в «условиях многопоточности» нужно искать в документации 
 подтверждение потокобезопасности («thread safety») или предупреждение о небезопасности использоваться в «условиях многопоточности».

2)Можно ли с "стандартными обобщёнными коллекциями" одновременно работать в разных потоках? Как это можно сделать?
 В можно выполнять несколько операций чтения List<T> , но при изменении коллекции во время ее чтения могут возникать проблемы. 
 Чтобы обеспечить безопасность потоков, заблокируйте коллекцию во время операции чтения или записи. Чтобы обеспечить доступ к коллекции из 
 нескольких потоков для чтения и записи, необходимо реализовать собственную синхронизацию.

3)Какие есть стандартные потоко-безопасные коллекции? Когда их следует применять?
В .NET Framework 4 появилось пять типов коллекций, специально разработанных для поддержки многопотоковых операций добавления и удаления -
ConcurrentQueue, ConcurrentStack, ConcurrentDictionary, ConcurrentBag, BlockingCollection.
 
Для достижения потокобезопасности эти типы используют различные виды эффективных механизмов синхронизации с блокировкой и без нее. Синхронизация 
добавляет к операции издержки. Значения издержек зависят от используемого типа синхронизации, выполняемого типа операции и других факторов, 
например количества потоков, которые одновременно пытаются получить доступ к коллекции.
В некоторых сценариях издержки синхронизации незначительны и позволяют многопотоковым вариантам выполняться значительно быстрее и обеспечивают
 лучшую масштабируемость, чем в случае потоконебезопасного эквивалента при защите с помощью внешней блокировки. В других сценариях издержки могут 
вызвать ситуацию, когда потокобезопасный вариант выполняется и масштабируется примерно так же и даже более медленно, чем потоконебезопасная версия 
типа с внешней блокировкой.

4)Как можно реализовать отложенную инициализацию в C#? 
 С помощью класса Lasy<T>. Чтобы подготовиться к отложенной инициализации, создайте экземпляр Lazy<T> . Аргумент типа создаваемого Lazy<T> объекта 
 указывает тип объекта, который требуется инициализировать отложенно. Конструктор, используемый для создания Lazy<T> объекта, определяет характеристики 
 инициализации. Отложенная инициализация производится при первом обращении к свойству Lazy<T>.Value.

5) Приведите примеры с кодом реализации паттерна Singleton в C#. Чем они отличаются? Как корректно реализовать Singleton в многопоточных приложения на .NET?  
Какие есть варианты?

Реализация с двойной проверкой - потокобезопасная
public sealed class Singleton
{
	private Singleton()
	{
		// инициализировать новый экземпляр объекта
	}

	private static volatile Singleton singletonInstance;

	private static readonly Object syncRoot = new Object();

	public static Singleton GetInstance()
	{
		// создан ли объект
		if(singletonInstance == null)
		{
			// нет, не создан
			// только один поток может создать его
			lock(syncRoot)
			{
				// проверяем, не создал ли объект другой поток
				if(singletonInstance == null)
				{
					// нет не создал — создаём
					singletonInstance = new Singleton();
				}
			}
		}
		return singletonInstance;
	}
}

Реализация на основе статичесокго конструктора - потоко безопасная.
Статический конструктор вызывается только 1 раз в домене приложения. Он вызывается только когда создается объект 
или вызывается статический член класса. Данная реализация не совсем ленивая.
 
public sealed class Singleton
{
    private static readonly Singleton instance = new Singleton();

    // Explicit static constructor to tell C# compiler
    // not to mark type as beforefieldinit
    static Singleton()
    {
    }

    private Singleton()
    {
    }

    public static Singleton Instance
    {
        get
        {
            return instance;
        }
    }
}

Полностью ленивая реализация на основе вложенного класса Nested.
используется ключевое слово internal так как без него класс Singleton не имел бы доступа к членам класса Nested
public sealed class Singleton
{
    private Singleton()
    {
    }

    public static Singleton Instance { get { return Nested.instance; } }

    private class Nested
    {
        // Explicit static constructor to tell C# compiler
        // not to mark type as beforefieldinit
        static Nested()
        {
        }

        internal static readonly Singleton instance = new Singleton();
    }
}

Потокобезопасная и ленивая реализация на основе класса Lazy<T> доступна с версии .NET 4 (или выше)
Рекомендуется использовать этот подход для корректной реализацииь Singleton в многопоточных приложения на .NET
public sealed class Singleton
{
    private static readonly Lazy<Singleton> lazy =
        new Lazy<Singleton>(() => new Singleton());

    public static Singleton Instance { get { return lazy.Value; } }

    private Singleton()
    {
    }
}
Приведенный выше код неявно использует LazyThreadSafetyMode.ExecutionAndPublicationв качестве режима потокобезопасности для Lazy<Singleton>.

6)В чём отличая между Concurrency и Multi-threading?

Concurrency просто означают одновременное выполнение нескольких операций. Это может быть достигнуто с помощью асинхронности или многопоточности. 

Многопоточность означает запуск более одного потока выполнения одновременно. В этой модели все операции по – прежнему синхронны, но процессор 
будет выполнять несколько потоков синхронных операций одновременно.
Многопоточность имеет наибольший смысл при вызове нескольких (и независимых) операций, связанных с процессором, на многоядерном процессоре. 
Например, программа, которая независимо анализирует каждый пиксель изображения, может разделить изображение на одну полосу для каждого ядра 
процессора, а затем проанализировать каждую полосу в своем потоке одновременно.
Обратите внимание, что нет никакого преимущества, полученного при запуске большего количества потоков, чем есть ядра процессора. 
Потоки волшебным образом не позволяют процессорам выполнять больше работы бесплатно; как только у вас закончатся выделенные ядра для запуска 
ваших потоков, вы в конечном итоге получите отдельные ядра, выполняющие биты каждого потока по очереди, добавляя дополнительные накладные 
расходы на переключение контекста, когда ядро переключается на каждый поток, и не получая никакого преимущества в производительности.


7)В чём отличая между Asynchronous и Multi-threading?
Асинхронная операция – это операция, которая продолжается в фоновом режиме после инициирования, не заставляя вызывающего абонента ждать ее 
завершения перед запуском другого кода. При асинхронных операцих потоки не блокируются и могут выполнять какую то другую полезную работу во время ожидания.