use Northwind

--1.a Написать процедуру, которая возвращает самый крупный заказ для каждого 
--из продавцов за определенный год. В результатах не может быть несколько
--заказов одного продавца, должен быть только один и самый крупный. В результатах
--запроса должны быть выведены следующие колонки: колонка с именем и фамилией
--продавца (FirstName и LastName – пример: Nancy Davolio), номер заказа и его 
--стоимость. В запросе надо учитывать Discount при продаже товаров. Процедуре 
--передается год, за который надо сделать отчет, и количество возвращаемых 
--записей. Результаты запроса должны быть упорядочены по убыванию суммы заказа. 
--Процедура должна быть реализована 2-мя способами: с использованием оператора 
--SELECT и с использованием курсора. Название функций соответственно GreatestOrders 
--и GreatestOrdersCur. Необходимо продемонстрировать использование этих процедур. 
--Также помимо демонстрации вызовов процедур в скрипте QueryB.sql надо написать 
--отдельный ДОПОЛНИТЕЛЬНЫЙ проверочный запрос для тестирования правильности работы 
--процедуры GreatestOrders. Проверочный запрос должен выводить в удобном для 
--сравнения с результатами работы процедур виде для определенного продавца для 
--всех его заказов за определенный указанный год в результатах следующие 
--колонки: имя продавца, номер заказа, сумму заказа. Проверочный запрос 
--не должен повторять запрос, написанный в процедуре, - он должен выполнять 
--только то, что описано в требованиях по нему.

EXEC GreatestOrders @year = 1997, @numberOfRows = 9;
GO  
	EXEC GreatestOrdersCur @year = 1997, @numberOfRows = 9;
GO

SELECT E.EmployeeID, FirstName + ' ' + E.LastName AS FullName, OD.OrderID, ROUND(SUM(OD.UnitPrice * OD.Quantity * (1 - OD.Discount)), 2) AS Total
FROM Orders O
JOIN [Order Details] OD ON O.OrderID = OD.OrderID
JOIN Employees E ON E.EmployeeID = O.EmployeeID
WHERE YEAR(O.OrderDate) = 1997 AND (FirstName + ' ' + E.LastName = 'Margaret Peacock')
GROUP BY E.EmployeeID, E.FirstName, E.LastName, OD.OrderID
ORDER BY Total DESC

--1.b Написать процедуру, которая возвращает заказы в таблице Orders, согласно указанному сроку 
--доставки в днях (разница между OrderDate и ShippedDate).  В результатах должны быть возвращены 
--заказы, срок которых превышает переданное значение, или еще недоставленные заказы. Значению 
--по умолчанию для передаваемого срока 35 дней. Название процедуры ShippedOrdersDiff. 
--Процедура должна высвечивать следующие колонки: OrderID, OrderDate, ShippedDate, ShippedDelay 
--(разность в днях между ShippedDate и OrderDate), SpecifiedDelay (переданное в процедуру значение).  
--Необходимо продемонстрировать использование этой процедуры.

GO  
	EXEC ShippedOrdersDiff @specifiedDelay = 20;
GO


--1.c Написать процедуру, которая высвечивает всех подчиненных заданного продавца, как непосредственных, 
--так и подчиненных его подчиненных. В качестве входного параметра функции используется EmployeeID. 
--Необходимо распечатать имена подчиненных и выровнять их в тексте (использовать оператор PRINT) 
--согласно иерархии подчинения. Продавец, для которого надо найти подчиненных, также должен быть высвечен. 
--Название процедуры SubordinationInfo. В качестве алгоритма для решения этой задачи надо использовать 
--пример, приведенный в Books Online и рекомендованный Microsoft для решения подобного типа задач. 
--Продемонстрировать использование процедуры.

GO  
	EXEC SubordinationInfo @employeeID = 2;
GO

--1.d Написать функцию, которая определяет, есть ли у продавца подчиненные. Возвращает тип данных BIT. В качестве 
--входного параметра функции используется EmployeeID. Название функции IsBoss. Продемонстрировать использование
--функции для всех продавцов из таблицы Employees.

DECLARE cur CURSOR FOR
SELECT  E.EmployeeID
FROM Employees AS E

OPEN cur
DECLARE @employee int

FETCH NEXT FROM cur INTO @employee
WHILE(@@FETCH_STATUS = 0)
BEGIN
	DECLARE @isboss BIT
    EXEC IsBoss @employee, @IsBoss = @isBoss OUTPUT
	PRINT('EmployeeID= ' + CONVERT(varchar(10),@employee)+ ' ' +'IS boss= '+ CONVERT(varchar(10), @isboss))
	FETCH NEXT FROM cur INTO @employee	
END
CLOSE cur
DEALLOCATE cur